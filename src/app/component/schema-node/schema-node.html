<div class="box" [style.marginLeft.px]="depth * 12">
  <div class="box-head" (click)="onHeaderClick($event)">
    <div class="left">
      <span class="tag">{{ node.name }}</span>
      <span class="doc" *ngIf="typeName">type: {{ typeName }}</span>
      <span class="doc" *ngIf="base" style="margin-left:8px">base: {{ base }}</span>
      <span class="doc" *ngIf="use" style="margin-left:8px">use: {{ use }}</span>
    </div>
    <div class="right">{{ open ? '▾' : '▸' }}</div>
  </div>

  <div class="box-body" *ngIf="open" (click)="$event.stopPropagation()">
    <!-- Documentação do nó-->
    <ng-container *ngIf="(node.meta?.docs || node.source?.meta?.docs) as docs">
      <div class="docbox">
        <div class="docline" *ngFor="let d of docs; trackBy: trackStr">{{ d }}</div>
      </div>
    </ng-container>

    <!-- Ocorrencias-->

    <div class="occurs" *ngIf="showOccursEditor">
      <div class="occ-row">
        <div class="occ-item" *ngIf="occurs?.min === 0 || occMin === 0">
          <label>Mínimo</label>
          <input type="number" min="0" [max]="occMax === 'unbounded' ? null : occMax"
                [value]="occMin" (input)="setOccMin(($event.target ).valueAsNumber)" />
        </div>

        <div class="occ-item">
          <label>Máximo</label>
          <ng-container *ngIf="occMax !== 'unbounded'; else unbounded">
            <input type="number" min="1" [value]="occMax"
                  (input)="setOccMax(($event.target).valueAsNumber)" />
          </ng-container>
          <ng-template #unbounded>
            <input type="number" [value]="50" (input)="setOccMax(($event.target ).valueAsNumber)" />
          </ng-template>
          <label class="chk">
            <input type="checkbox" [checked]="occMax === 'unbounded'" (change)="toggleUnbounded(($event.target).checked)" />
            ilimitado
          </label>
        </div>

        <div class="occ-hint">
          <span>Atual: {{ occurs?.min ?? 1 }}..{{ occurs?.max === 'unbounded' ? '∞' : occurs?.max ?? 1 }}</span>
          <span *ngIf="occMin !== (occurs?.min ?? 1) || occMax !== (occurs?.max ?? 1)">→ Novo: {{ occMin }}..{{ occMax === 'unbounded' ? '∞' : occMax }}</span>
        </div>
      </div>
    </div>

    <!-- FORM de Numeric Facet -->

    <div class="num-box" *ngIf="showNumericEditor">
      <div class="sf-row" *ngIf="showMinInclusive">
        <label class="lbl">Mínimo (inclusive)</label>
        <input type="number"
              [value]="nfDraft.minInclusive ?? numericFacets?.minInclusive ?? inferredNum?.min ?? ''"
              (input)="setMinInclusive(($event.target ).valueAsNumber)">
        <span class="hint" *ngIf="numericFacets?.minInclusive === undefined && inferredNum?.min !== undefined">
          sugerido: {{ inferredNum?.min }}
        </span>
      </div>

      <div class="sf-row" *ngIf="showMinExclusive">
        <label class="lbl">Mínimo (exclusive)</label>
        <input type="number"
              [value]="nfDraft.minExclusive ?? numericFacets?.minExclusive ?? ''"
              (input)="setMinExclusive(($event.target ).valueAsNumber)">
      </div>

      <div class="sf-row" *ngIf="showMaxInclusive">
        <label class="lbl">Máximo (inclusive)</label>
        <input type="number"
              [value]="nfDraft.maxInclusive ?? numericFacets?.maxInclusive ?? inferredNum?.max ?? ''"
              (input)="setMaxInclusive(($event.target ).valueAsNumber)">
        <span class="hint" *ngIf="numericFacets?.maxInclusive === undefined && inferredNum?.max !== undefined">
          sugerido: {{ inferredNum?.max }}
        </span>
      </div>

      <div class="sf-row" *ngIf="showMaxExclusive">
        <label class="lbl">Máximo (exclusive)</label>
        <input type="number"
              [value]="nfDraft.maxExclusive ?? numericFacets?.maxExclusive ?? ''"
              (input)="setMaxExclusive(($event.target ).valueAsNumber)">
      </div>

      <div class="sf-row" *ngIf="showTotalDigits">
        <label class="lbl">totalDigits</label>
        <input type="number" min="1"
              [value]="nfDraft.totalDigits ?? numericFacets?.totalDigits ?? ''"
              (input)="setTotalDigits(($event.target ).valueAsNumber)">
      </div>

      <div class="sf-row" *ngIf="showFractionDigits">
        <label class="lbl">fractionDigits</label>
        <input type="number" min="0"
              [value]="nfDraft.fractionDigits ?? numericFacets?.fractionDigits ?? ''"
              (input)="setFractionDigits(($event.target ).valueAsNumber)">
        <span class="hint">para decimais (xs:decimal)</span>
      </div>

      <div class="sf-row" *ngIf="showNumPattern">
        <label class="lbl">Pattern (regex)</label>
        <input type="text"
              [value]="nfDraft.pattern ?? numericFacets?.pattern ?? ''"
              (input)="setNumPattern(($event.target ).value)">
      </div>
    </div>


    <!-- FORM de string facets -->
    <div class="sf-box" *ngIf="showStringEditor">
      <div class="sf-row">
        <label class="lbl">Mínimo</label>
        <input type="number"
              [value]="minLenForForm"
              (input)="setMinLen(($event.target).valueAsNumber)">
        <span class="hint" *ngIf="stringFacets?.minLength===undefined && inferredString?.minLength">
          sugerido: {{ inferredString?.minLength }}
        </span>
      </div>

      <div class="sf-row">
        <label class="lbl">Máximo</label>
        <input type="number"
              [value]="maxLenForForm"
              (input)="setMaxLen(($event.target).valueAsNumber)">
        <span class="hint" *ngIf="stringFacets?.maxLength===undefined && inferredString?.maxLength">
          sugerido: {{ inferredString?.maxLength }}
        </span>
      </div>

      <div class="sf-row">
        <label class="lbl">Pattern (regex)</label>
        <input type="text" [value]="(sfDraft.patterns?.[0] ?? stringFacets?.patterns?.[0]) || ''"
              placeholder="ex.: ^\\S.*$" (input)="setPattern(($event.target).value)">
        <span class="hint">adicionar/substituir (mais restritivo)</span>
      </div>
    </div>
    <!-- ↓↓↓ enum como LISTA (sem caixas/toggle) ↓↓↓ -->
    <ng-container *ngIf="node.kind === 'enumeration'; else normalChildren">
      <div class="enum-list">
        <div class="enum-row"
             *ngFor="let val of (node.children || []); trackBy: trackById"
             [class.removed]="isEnumRemoved(val)">
          <div class="enum-left">
            <strong class="enum-value">{{ val.name }}</strong>
            <span class="enum-doc" *ngIf="(val.meta?.docs || val.source?.meta?.docs) as vdocs">
              {{ vdocs[0] || '' }}
            </span>
          </div>
          <div class="enum-actions">
            <button class="btn danger" *ngIf="!isEnumRemoved(val)" (click)="removeEnum(val)">Remover</button>
            <button class="btn" *ngIf="isEnumRemoved(val)" (click)="undoEnum(val)">Desfazer</button>
          </div>
        </div>
      </div>
    </ng-container>

    <!-- render padrão (não-enum) -->
    <ng-template #normalChildren>
      <ng-container *ngIf="filteredChildren().length; else leaf">
        <app-schema-node
          *ngFor="let c of filteredChildren(); trackBy: trackById"
          [node]="c"
          [depth]="depth + 1">
        </app-schema-node>
      </ng-container>
      <ng-template #leaf>
      </ng-template>
    </ng-template>
  </div>
</div>